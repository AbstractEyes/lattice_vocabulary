"""
SYMBOLIC_TREE USAGE GUIDE
==========================

The symbolic_tree module provides intelligent navigation and data access
for the hierarchical category structure, with direct integration to BulkCaptions.

IMPORT
------
from geovocab2.data.prompt.symbolic_tree import CategoryTreeNavigator

INITIALIZATION
--------------
nav = CategoryTreeNavigator()


CORE DATA ACCESS METHODS
-------------------------

1. GET DATA FOR A CATEGORY
   data = nav.get_data("pose")
   # Returns: BulkCaptions.HUMAN_POSES list

2. SAMPLE RANDOM ITEMS
   items = nav.sample_data("pose", n=3)
   # Returns: 3 random poses from BulkCaptions.HUMAN_POSES

3. GET SINGLE RANDOM ITEM
   item = nav.get_random_item("emotion")
   # Returns: one random emotion

4. GET DATA SIZE
   size = nav.get_data_size("upper_clothing")
   # Returns: length of BulkCaptions.UPPER_BODY_CLOTHES_TYPES

5. MULTI-CATEGORY BATCH ACCESS
   data = nav.get_multi_category_data(
       ["pose", "emotion", "lighting"],
       samples_per_category=2
   )
   # Returns: {"pose": [...], "emotion": [...], "lighting": [...]}


NAVIGATION METHODS
------------------

1. GET HIERARCHICAL PATH
   path = nav.get_path("pose")
   # Returns: ["human", "anatomy", "pose"]

2. GET PARENT CATEGORY
   parent = nav.get_parent("pose")
   # Returns: "anatomy"

3. GET SIBLINGS
   siblings = nav.get_siblings("upper_clothing")
   # Returns: ["lower_clothing", "footwear", "accessory", ...]

4. GET ROOT DOMAIN
   domain = nav.get_root_domain("pose")
   # Returns: "human"

5. GET LIST NAME
   list_name = nav.get_list_name("pose")
   # Returns: "HUMAN_POSES"


COMPATIBILITY & COMPOSITION
----------------------------

1. CHECK COMPATIBILITY
   score = nav.are_compatible("pose", "emotion")
   # Returns: 0.8 (same domain)

2. SUGGEST COMPOSITION PARTNERS
   partners = nav.suggest_composition_partners("subject", n=5)
   # Returns: [("pose", 0.9), ("emotion", 0.9), ("background", 0.85), ...]

3. GENERATE SEMANTIC CHAIN
   chain = nav.get_composition_chain("subject", depth=4)
   # Returns: ["subject", "pose", "lighting", "color"]

4. COMPOSE WITH ACTUAL DATA
   composition = nav.compose_semantic("subject", depth=3)
   # Returns:
   # {
   #     'chain': ['subject', 'pose', 'emotion'],
   #     'items': {
   #         'subject': 'person',
   #         'pose': 'standing',
   #         'emotion': 'happy'
   #     },
   #     'compatibility_scores': [0.9, 0.8]
   # }

5. GET DATA FOR CHAIN
   chain = ["pose", "emotion", "lighting"]
   items = nav.compose_from_chain(chain)
   # Returns: {"pose": "walking", "emotion": "happy", "lighting": "bright"}


TREE STRUCTURE
--------------

DOMAINS (5 top-level):
  • subject   - Entities, identity (12 categories, ~1000 items)
  • human     - Anatomy, attire, expression (14 categories, ~5000 items)
  • context   - Environment, materials, depiction (18 categories, ~3000 items)
  • shared    - Descriptors, modifiers (10 categories, ~1200 items)
  • symbolic  - Logic, semantic associations (6 categories, ~3800 items)

EXAMPLE PATHS:
  pose          → human → anatomy → pose → HUMAN_POSES
  upper_clothing → human → attire → upper_clothing → UPPER_BODY_CLOTHES_TYPES
  lighting      → context → depiction → composition → lighting → LIGHTING_TYPES
  color         → shared → descriptors → color → COLORS


COMPATIBILITY SCORING
---------------------

Scores range from 0.0 (incompatible) to 1.0 (perfect match):
  • 0.3 - Same category (redundant)
  • 0.7 - Sibling categories
  • 0.8 - Same parent or same domain
  • 0.9 - High cross-domain compatibility (subject+human, human+context)
  • 0.85 - Medium cross-domain (subject+context, context+shared)
  • 0.6-0.7 - Symbolic with other domains


PRACTICAL EXAMPLES
------------------

EXAMPLE 1: Build a person description
    nav = CategoryTreeNavigator()

    # Get compatible elements
    person = nav.get_random_item("subject")      # "person"
    pose = nav.get_random_item("pose")           # "standing"
    clothing = nav.get_random_item("upper_clothing")  # "shirt"
    emotion = nav.get_random_item("emotion")     # "smiling"

    # Build caption
    caption = f"a {person} {pose} wearing a {clothing}, {emotion}"
    # Result: "a person standing wearing a shirt, smiling"

EXAMPLE 2: Generate semantic composition automatically
    composition = nav.compose_semantic("subject", depth=5)

    # Builds coherent chain and samples data
    # composition['chain']: ['subject', 'pose', 'emotion', 'lighting', 'color']
    # composition['items']: {'subject': 'person', 'pose': 'sitting', ...}
    # composition['compatibility_scores']: [0.9, 0.8, 0.85, 0.8]

EXAMPLE 3: Batch data access for multiple captions
    categories = ["pose", "emotion", "upper_clothing", "lighting"]
    batch_data = nav.get_multi_category_data(categories, samples_per_category=10)

    # batch_data contains 10 samples for each category
    for i in range(10):
        caption = f"{batch_data['pose'][i]} {batch_data['emotion'][i]} " \
                  f"in {batch_data['upper_clothing'][i]}, {batch_data['lighting'][i]} lighting"

EXAMPLE 4: Find high-compatibility pairs
    partners = nav.suggest_composition_partners("pose", n=10)

    # Get top compatible categories with actual data
    for category, score in partners:
        sample = nav.get_random_item(category)
        print(f"{category} ({score:.2f}): {sample}")


VALIDATION
----------

Check tree integrity and data availability:
    report = nav.validate_tree()

    print(f"Total categories: {report['total_categories']}")
    print(f"Missing data: {len(report['missing_data'])}")

    # Check each domain
    for domain, info in report['categories_per_domain'].items():
        print(f"{domain}: {info['count']} categories, {info['total_items']} items")


SPECIAL FEATURES
----------------

1. DETERMINISTIC SAMPLING
   Random sampling uses system random - seed it for reproducibility:

   import random
   random.seed(42)
   item = nav.get_random_item("pose")  # Always returns same item

2. EMPTY DATA HANDLING
   All methods gracefully handle missing/empty data:

   data = nav.get_data("nonexistent")  # Returns None
   items = nav.sample_data("empty_category", n=5)  # Returns []
   item = nav.get_random_item("missing")  # Returns None

3. COMPATIBILITY CACHING
   Path and sibling lookups are cached for performance.
   Tree traversal is O(1) after initial cache build.


INTEGRATION WITH CAPTION SYNTHESIS
-----------------------------------

Use with SymbolicCaptionSynthesizer:

from geovocab2.data.prompt.symbolic_tree import CategoryTreeNavigator
from geovocab2.data.prompt.caption_synthesizer import SymbolicCaptionSynthesizer

nav = CategoryTreeNavigator()
synthesizer = SymbolicCaptionSynthesizer(
    bulk_captions=BulkCaptions,
    navigator=nav,
    tokenizer=your_tokenizer
)

# Synthesizer can now use tree intelligence for composition
caption = synthesizer.synthesize(
    primary_category="subject",
    complexity=3,
    mode="tree_aware"  # Uses navigator for semantic coherence
)
"""